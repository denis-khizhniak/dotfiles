#!/bin/bash
#
# ~/.function
#

# Create a directory and immediately move into it
mcd()
{
  mkdir -p $1
  cd $1
}

# Change directory and list contained files
cl()
{
  local dir="$1"
  local dir="${dir:=$HOME}"
  if [[ -d "$dir" ]]; then
    cd "$dir" >/dev/null; ls -lh
  else
    echo "bash: cl: $dir: Directory not found"
  fi
}

# Run RDP with configuration file specified
#
# argument is the file - required
rdp()
{
  local DEFAULT_FILE=".rdp_WSM8-0089"
  local FILE="${1:-${DEFAULT_FILE}}"

  cat "$FILE" | xargs -rd $'\n' xfreerdp
}

# Run VPN connection with configuration file specified
#
# Arguments:
#   file - optional
#   server - required
vpn()
{
  local DEFAULT_SERVER="ras01.netcracker.com"

  for i in "$@"; do
    [ -f $i ] && local FILE="$i" || local SERVER="$i"
  done

  sudo openconnect --config=${FILE} ${SERVER:=${DEFAULT_SERVER}}
}

# Simple TODO
todo()
{
  local DOTFILES="${HOME}/Projects/dotfiles"

  local TODO="todo"
  local TODO_LN="${HOME}/.${TODO}"

  local SOLUTION="solution"
  local SOLUTION_LN="${HOME}/.${SOLUTION}"

  if [[ ! -f "${DOTFILES}/${TODO}" ]]; then
    touch "${DOTFILES}/${TODO}"
  fi

  if [[ ! -f "${DOTFILES}/${SOLUTION}" ]]; then
    touch "${DOTFILES}/${SOLUTION}"
  fi

  # Create symlinks (force)
  ln -sf "${DOTFILES}/${TODO}" "${TODO_LN}"
  ln -sf "${DOTFILES}/${SOLUTION}" "${SOLUTION_LN}"

  # Get the last item number
  get_max_item_num()
  {
    echo $(awk -F '$' -v max=0 '{if($1>max) {max=$1} } END{print max}' $1)
  }

  # Manage solutions for todos
  solution()
  {
    if (("$1")); then
      # Show solution
      local result=$(sed -n "/${1}\\$/ s/${1}\\$//p" "$SOLUTION_LN")
      ! ((${#result})) && echo "No matched solutions!" || echo "$result"
    elif [[ "$1" == "-a" ]]; then
      # Add solution
      read -ep "Enter your solution: " result
      echo "Added solution: \"$result\""
      printf "%s\n" "${2}\$${result}" >> "$SOLUTION_LN"
    elif [[ "$1" == "-r" ]]; then
      # Remove solution
      echo "Removed solution: \"$(sed -n "/${2}\\$/p" "$SOLUTION_LN")\""
      sed -i --follow-symlinks "/${2}\\$/d" "$SOLUTION_LN"
    else
      # List solutions with numbers
      column -ts '$' "$SOLUTION_LN" | less
    fi
  }

  if ! (($#)); then
    # Print todos
    awk -F '$' '{print $3}' "$TODO_LN" | less
  elif [[ "$1" == "-l" ]]; then
    # List todos with numbers
    sed -nr "/\[ \]/ s/\[ \]\\$//p" "$TODO_LN" | column -ts '$' | less
  elif [[ "$1" == "-a" ]]; then
    # List all todos with numbers
    column -ts '$' "$TODO_LN" | less
  elif [[ "$1" == "-c" ]]; then
    # Clear all todos
    > "$TODO_LN"
  elif [[ "$1" == "-d" ]]; then
    # Do todo
    sed -nr "/\[ \]/ s/\[ \]\\$//p" "$TODO_LN" | column -ts '$' | less
    read -p "Type a number to do: " number
    echo "Done item: \"$(awk -F '$' -v number=$number '{if($1==number) print $3}' "$TODO_LN")\""
    sed -i --follow-symlinks "/${number}\\$/ s/\[ \]/[x]/" "$TODO_LN"
    read -n 1 -p "Post solution (Y/n)? " answer; echo
    [[ ${answer:-y} = [Yy] ]] && solution -a "$number"
  elif [[ "$1" == "-p" ]]; then
    # Post solution
    sed -nr "/\[ \]/ s/\[ \]\\$//p" "$TODO_LN" | column -ts '$' | less
    read -p "Type a number to post solution for: " number
    solution -a "$number"
  elif [[ "$1" == "-s" ]]; then
    # Show solutions
    (("$2")) && solution "$2" || solution
  elif [[ "$1" == "-u" ]]; then
    # Undo todo
    sed -nr "/\[x\]/ s/\[x\]\\$//p" "$TODO_LN" | column -ts '$' | less
    read -p "Type a number to undo: " number
    echo "Undone item: \"$(awk -F '$' -v number=$number '{if($1==number) print $3}' "$TODO_LN")\""
    sed -i --follow-symlinks "/${number}\\$/ s/\[x\]/[ ]/" "$TODO_LN"
    solution -r "$number"
  elif [[ "$1" == "-r" ]]; then
    # Remove todo
    sed -nr "/\[ \]/ s/\[ \]\\$//p" "$TODO_LN" | column -ts '$' | less
    read -p "Type a number to remove: " number
    echo "Removed item: \"$(awk -F '$' -v number=$number '{if($1==number) print $3}' "$TODO_LN")\""
    sed -i --follow-symlinks "/${number}\\$/d" "$TODO_LN"
    solution -r "$number"
  else
    # Add todo
    local max_item_num=$(get_max_item_num)
    echo "Added item: \"${*}\""
    printf "%s\n" "${max_item_num}\$[ ]\$${*}" >> "$TODO_LN"
  fi

  unset get_max_item_num
  unset solution
}

# Decompress any compressed file format
extract()
{
 if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
    echo "       extract <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
    return 1
 else
    for n in $@
    do
      if [ -f "$n" ] ; then
          case "${n%,}" in
            *.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar)
                         tar xvf "$n"       ;;
            *.lzma)      unlzma ./"$n"      ;;
            *.bz2)       bunzip2 ./"$n"     ;;
            *.rar)       unrar x -ad ./"$n" ;;
            *.gz)        gunzip ./"$n"      ;;
            *.zip)       unzip ./"$n"       ;;
            *.z)         uncompress ./"$n"  ;;
            *.7z)        7z x ./"$n"        ;;
            *.xz)        unxz ./"$n"        ;;
            *.exe)       cabextract ./"$n"  ;;
            *)
                         echo "extract: '$n' - unknown archive method"
                         return 1
                         ;;
          esac
      else
          echo "'$n' - file does not exist"
          return 1
      fi
    done
fi
}

# Compile and execute a C source on the fly
csource()
{
  [[ $1 ]]    || { echo "Missing operand" >&2; return 1; }
  [[ -r $1 ]] || { printf "File %s does not exist or is not readable\n" "$1" >&2; return 1; }
  local output_path=${TMPDIR:-/tmp}/${1##*/};
  gcc "$1" -o "$output_path" && "$output_path";
  rm "$output_path";
  return 0;
}

# Calculator
calc()
{
    echo "scale=3;$@" | bc -l
}

# Find by name
ff() { find . -name $@ -print; }

# Kill process by name
kp()
{
  ps aux | grep $1 > /dev/null
  mypid=$(pidof $1)
  if [ "$mypid" != "" ]; then
    kill -9 $(pidof $1)
    if [[ "$?" == "0" ]]; then
      echo "PID $mypid ($1) killed."
    fi
  else
    echo "None killed."
  fi
  return;
}

# Get common xpath part for attributes and nodes
# Parse input parameters into path nodes for xpath
#
# INPUT:
# Provide any number of word-parameters to the script
#
# OUTPUT:
# The result would be multiple strings corresponding found records
keys()
{
  local FILE="$HOME"/keys.xml

  local xpath_base=""
  for i in "$@"; do
    xpath_base="${xpath_base}/*[starts-with(name(), '${i}')]/"
  done
  xpath_base="${xpath_base}/keys"

  # Get full command for extracting particular part, whether attribute or node
  #
  # INPUT:
  # $1 = 'attr' / 'node'
  # $2 = file
  #
  # OUTPUT:
  # string
  extract_xpath() {
    case $1 in
      'attr')
        local grep_case='".*"'
        local fs_case='"'
        ;;
      'node')
        local grep_case='>.*<'
        local fs_case='<|>'
        ;;
      *)
        echo "Wrong parameter"
        ;;
    esac

    echo cat "$xpath_base" | xmllint --shell "$2" | sed '/-\+/d' | egrep -o "$grep_case" | tr -d "$fs_case"
  }

  mapfile -t local attributes < <(extract_xpath attr "$FILE")
  mapfile -t local values < <(extract_xpath node "$FILE")

  for (( c=0; c<${#attributes[@]}; c++ )); do
    echo "${attributes[$c]}: ${values[$c]}"
  done
}

# Colored man
man()
{
  LESS_TERMCAP_md=$'\e[01;31m' \
  LESS_TERMCAP_me=$'\e[0m' \
  LESS_TERMCAP_se=$'\e[0m' \
  LESS_TERMCAP_so=$'\e[01;44;33m' \
  LESS_TERMCAP_ue=$'\e[0m' \
  LESS_TERMCAP_us=$'\e[01;32m' \
  command man "$@"
}
